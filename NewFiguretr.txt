
// Given the theta matrix, generate new transforms for all the joints.
void fixup_transforms() {
  switch( angle ) {
  case Torso:
    nodes[Torso].transform =
      RotateY( theta[Torso] );
    break;

  case Head1: case Head2:
    nodes[Head].transform =
      Translate(0.0, TORSO_HEIGHT+0.5*HEAD_HEIGHT, 0.0) *
      RotateX(theta[Head1]) *
      RotateY(theta[Head2]) *
      Translate(0.0, -0.5*HEAD_HEIGHT, 0.0);
    break;

  case LeftUpperArm:
    nodes[LeftUpperArm].transform =
      Translate(-(TORSO_WIDTH+UPPER_ARM_WIDTH),
		0.9*TORSO_HEIGHT, 0.0) *
      RotateX(theta[LeftUpperArm]);
    break;

  case RightUpperArm:
    nodes[RightUpperArm].transform =
      Translate(TORSO_WIDTH+UPPER_ARM_WIDTH, 0.9*TORSO_HEIGHT, 0.0) *
      RotateX(theta[RightUpperArm]);
    break;

  case RightUpperLeg:
    nodes[RightUpperLeg].transform =
      Translate(TORSO_WIDTH+UPPER_LEG_WIDTH,
		0.1*UPPER_LEG_HEIGHT, 0.0) *
      RotateX(theta[RightUpperLeg]);
    break;

  case LeftUpperLeg:
    nodes[LeftUpperLeg].transform =
      Translate(-(TORSO_WIDTH+UPPER_LEG_WIDTH),
		0.1*UPPER_LEG_HEIGHT, 0.0) *
      RotateX(theta[LeftUpperLeg]);
    break;

  case LeftLowerArm:
    nodes[LeftLowerArm].transform =
      Translate(0.0, UPPER_ARM_HEIGHT, 0.0) *
      RotateX(theta[LeftLowerArm]);
    break;

  case LeftLowerLeg:
    nodes[LeftLowerLeg].transform =
      Translate(0.0, UPPER_LEG_HEIGHT, 0.0) *
      RotateX(theta[LeftLowerLeg]);
    break;

  case RightLowerLeg:
    nodes[RightLowerLeg].transform =
      Translate(0.0, UPPER_LEG_HEIGHT, 0.0) *
      RotateX(theta[RightLowerLeg]);
    break;

  case RightLowerArm:
    nodes[RightLowerArm].transform =
      Translate(0.0, UPPER_ARM_HEIGHT, 0.0) *
      RotateX(theta[RightLowerArm]);
    break;
  }
}

// Speed of rotations (adjust for different machines)
// Note: should modify to be consistent by using glutelapsedtime().
GLfloat incr = 5.0;
void idle(){

  if(moving) {
    if (forwards) {
      theta[angle] += incr;
    } else {
      theta[angle] -= incr;
    }
    if( theta[angle] > 360.0 ) theta[angle] -= 360.0;
    if( theta[angle] < 0.0 ) theta[angle] += 360.0;
    fixup_transforms();
    glutPostRedisplay();
  }

}

//----------------------------------------------------------------------------

void
torso()
{
  // Is the next call necessary?
  mvstack.push( model_view );

  mat4 instance = ( Translate( 0.0, 0.5 * TORSO_HEIGHT, 0.0 ) *
		    Scale( TORSO_WIDTH, TORSO_HEIGHT, TORSO_WIDTH ) );

  glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
  glDrawArrays( GL_TRIANGLES, 0, NumVertices );

  // Is the next call necessary?
  model_view = mvstack.pop();
}

void
head()
{
    mvstack.push( model_view );

    mat4 instance = (Translate( 0.0, 0.5 * HEAD_HEIGHT, 0.0 ) *
		     Scale( HEAD_WIDTH, HEAD_HEIGHT, HEAD_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}

void
left_upper_arm()
{
    mvstack.push( model_view );

    mat4 instance = (Translate( 0.0, 0.5 * UPPER_ARM_HEIGHT, 0.0 ) *
		     Scale( UPPER_ARM_WIDTH,
			    UPPER_ARM_HEIGHT,
			    UPPER_ARM_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}

void
left_lower_arm()
{
    mvstack.push( model_view );

    mat4 instance = ( Translate( 0.0, 0.5 * LOWER_ARM_HEIGHT, 0.0 ) *
		      Scale( LOWER_ARM_WIDTH,
			     LOWER_ARM_HEIGHT,
			     LOWER_ARM_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}

void
right_upper_arm()
{
    mvstack.push( model_view );

    mat4 instance = (Translate( 0.0, 0.5 * UPPER_ARM_HEIGHT, 0.0 ) *
		     Scale( UPPER_ARM_WIDTH,
			    UPPER_ARM_HEIGHT,
			    UPPER_ARM_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}

void
right_lower_arm()
{
    mvstack.push( model_view );

    mat4 instance = (Translate( 0.0, 0.5 * LOWER_ARM_HEIGHT, 0.0 ) *
		     Scale( LOWER_ARM_WIDTH,
			    LOWER_ARM_HEIGHT,
			    LOWER_ARM_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}

void
left_upper_leg()
{
    mvstack.push( model_view );

    mat4 instance = ( Translate( 0.0, 0.5 * UPPER_LEG_HEIGHT, 0.0 ) *
		      Scale( UPPER_LEG_WIDTH,
			     UPPER_LEG_HEIGHT,
			     UPPER_LEG_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}

void
left_lower_leg()
{
    mvstack.push( model_view );

    mat4 instance = (Translate( 0.0, 0.5 * LOWER_LEG_HEIGHT, 0.0 ) *
		     Scale( LOWER_LEG_WIDTH,
			    LOWER_LEG_HEIGHT,
			    LOWER_LEG_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}

void
right_upper_leg()
{
    mvstack.push( model_view );

    mat4 instance = (Translate( 0.0, 0.5 * UPPER_LEG_HEIGHT, 0.0 ) *
		     Scale( UPPER_LEG_WIDTH,
			    UPPER_LEG_HEIGHT,
			    UPPER_LEG_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}

void
right_lower_leg()
{
    mvstack.push( model_view );

    mat4 instance = ( Translate( 0.0, 0.5 * LOWER_LEG_HEIGHT, 0.0 ) *
		      Scale( LOWER_LEG_WIDTH,
			     LOWER_LEG_HEIGHT,
			     LOWER_LEG_WIDTH ) );

    glUniformMatrix4fv( ModelView, 1, GL_TRUE, model_view * instance );
    glDrawArrays( GL_TRIANGLES, 0, NumVertices );

    model_view = mvstack.pop();
}


//----------------------------------------------------------------------------

void mouse( int button, int state, int x, int y )
{
  if ( button == GLUT_LEFT_BUTTON && state == GLUT_DOWN ) {
    moving=true;
    forwards=true;
    //        theta[angle] += 5.0;
    //        if ( theta[angle] > 360.0 ) { theta[angle] -= 360.0; }
  }
  if ( button == GLUT_LEFT_BUTTON && state == GLUT_UP ) {
    moving=false;
  }

  if ( button == GLUT_RIGHT_BUTTON && state == GLUT_DOWN ) {
    moving=true;
    forwards=false;
    //        theta[angle] -= 5.0;
    //        if ( theta[angle] < 0.0 ) { theta[angle] += 360.0; }
  }
  if ( button == GLUT_RIGHT_BUTTON && state == GLUT_UP ) {
    moving=false;
  }

  //mvstack.push( model_view );

  //    fixup_transforms(angle);
  // model_view = mvstack.pop();
  glutPostRedisplay();
}

//----------------------------------------------------------------------------

void menu( int option ) {
    if ( option == Quit ) exit( EXIT_SUCCESS );
    angle = option;
}

//----------------------------------------------------------------------------

void reshape( int width, int height ) {
    glViewport( 0, 0, width, height );

    GLfloat left = -10.0, right = 10.0;
    GLfloat bottom = -10.0, top = 10.0;
    //    GLfloat zNear = -10.0, zFar = 10.0;

    GLfloat aspect = GLfloat( width ) / height;

    if ( aspect > 1.0 ) {
        left *= aspect;
        right *= aspect;
    }
    else {
        bottom /= aspect;
        top /= aspect;
    }

    //    mat4 projection = Ortho( left, right, bottom, top, zNear, zFar );

    mat4 projection = Perspective(80, aspect, 0.1, 100.0);
    glUniformMatrix4fv( Projection, 1, GL_TRUE, projection );

    //    model_view = mat4( 1.0 );   // An Identity matrix
    model_view = Translate(0,0,-15);   // Initial camera translation
}
